/*
 * Blind Insight REST API
 *
 * End-to-end encrypted datastore
 *
 * The version of the OpenAPI document: 10.6.2
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`organizations_audit_logs_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsAuditLogsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_audit_logs_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsAuditLogsRetrieveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_by_slug`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsBySlugError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_dataset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsDatasetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsDestroyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_invitations_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsInvitationsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_invitations_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsInvitationsDestroyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_invitations_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsInvitationsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_invitations_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsInvitationsPartialUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_invitations_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsInvitationsRetrieveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_invitations_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsInvitationsUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_owner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOwnerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPartialUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsRetrieveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_teams_add_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsTeamsAddMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_teams_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsTeamsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_teams_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsTeamsDestroyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_teams_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsTeamsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_teams_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsTeamsPartialUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_teams_remove_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsTeamsRemoveMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_teams_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsTeamsRetrieveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_teams_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsTeamsUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_users_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsUsersCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_users_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsUsersDestroyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_users_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsUsersListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_users_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsUsersPartialUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_users_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsUsersRetrieveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_users_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsUsersUpdateError {
    UnknownValue(serde_json::Value),
}


/// Return a list of all organization audit logs.
pub async fn organizations_audit_logs_list(configuration: &configuration::Configuration, organization_id: &str, action: Option<i32>, actor: Option<&str>, actor_email: Option<&str>, changes_text: Option<&str>, cid: Option<&str>, content_type: Option<i32>, limit: Option<i32>, object_id: Option<i32>, object_pk: Option<&str>, object_repr: Option<&str>, offset: Option<i32>, remote_addr: Option<&str>, remote_port: Option<i32>, timestamp: Option<String>) -> Result<Vec<models::AuditLogEntry>, Error<OrganizationsAuditLogsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_action = action;
    let p_actor = actor;
    let p_actor_email = actor_email;
    let p_changes_text = changes_text;
    let p_cid = cid;
    let p_content_type = content_type;
    let p_limit = limit;
    let p_object_id = object_id;
    let p_object_pk = object_pk;
    let p_object_repr = object_repr;
    let p_offset = offset;
    let p_remote_addr = remote_addr;
    let p_remote_port = remote_port;
    let p_timestamp = timestamp;

    let uri_str = format!("{}/api/organizations/{organization_id}/audit-logs/", configuration.base_path, organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_actor {
        req_builder = req_builder.query(&[("actor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_actor_email {
        req_builder = req_builder.query(&[("actor_email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_changes_text {
        req_builder = req_builder.query(&[("changes_text", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cid {
        req_builder = req_builder.query(&[("cid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_content_type {
        req_builder = req_builder.query(&[("content_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_object_id {
        req_builder = req_builder.query(&[("object_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_object_pk {
        req_builder = req_builder.query(&[("object_pk", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_object_repr {
        req_builder = req_builder.query(&[("object_repr", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_remote_addr {
        req_builder = req_builder.query(&[("remote_addr", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_remote_port {
        req_builder = req_builder.query(&[("remote_port", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_timestamp {
        req_builder = req_builder.query(&[("timestamp", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AuditLogEntry&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AuditLogEntry&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsAuditLogsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a single organization audit log by its ID.
pub async fn organizations_audit_logs_retrieve(configuration: &configuration::Configuration, id: i32, organization_id: &str) -> Result<models::AuditLogEntry, Error<OrganizationsAuditLogsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;

    let uri_str = format!("{}/api/organizations/{organization_id}/audit-logs/{id}/", configuration.base_path, id=p_id, organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuditLogEntry`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuditLogEntry`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsAuditLogsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a single organization by its slug.  The response will be the organization object.  **On the command line:**  ```bash blind organizations by-slug --slug \"<organization-slug>\" ```
pub async fn organizations_by_slug(configuration: &configuration::Configuration, slug: &str) -> Result<models::Organization, Error<OrganizationsBySlugError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/api/organizations/by-slug/{slug}/", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Organization`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Organization`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsBySlugError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new organization. The only required field is `name`. The currently authenticated user will be set as the owner of the organization.  The response will be the newly created organization object.  **On the command line:**  ```bash blind organizations create --data '{\"name\": \"Example Organization\"}' ```
pub async fn organizations_create(configuration: &configuration::Configuration, organization_create: models::OrganizationCreate) -> Result<models::OrganizationCreate, Error<OrganizationsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_create = organization_create;

    let uri_str = format!("{}/api/organizations/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_create);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationCreate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationCreate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a single organization dataset by its slug.  The response is the dataset object.  **On the command line:**  ```bash blind organizations dataset --id \"<organization-id>\" --slug \"<dataset-slug>\" ```
pub async fn organizations_dataset(configuration: &configuration::Configuration, id: &str, slug: &str) -> Result<models::Organization, Error<OrganizationsDatasetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_slug = slug;

    let uri_str = format!("{}/api/organizations/{id}/dataset/{slug}/", configuration.base_path, id=crate::apis::urlencode(p_id), slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Organization`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Organization`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsDatasetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an organization. Note that this does not delete the organization's members or any associated data.  The response will be a 204 No Content if successful.  **On the command line:**  ```bash blind organizations destroy --id \"<organization-id>\" ```
pub async fn organizations_destroy(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<OrganizationsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/api/organizations/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Invite a user to join an organization.  The response is the newly created invitation object.  **On the command line:**  ```bash blind organizations invitations create --organization-id \"<organization-id>\" --data organization-invitation.json ```
pub async fn organizations_invitations_create(configuration: &configuration::Configuration, organization_id: &str, organization_invitation_create: models::OrganizationInvitationCreate) -> Result<models::OrganizationInvitationCreate, Error<OrganizationsInvitationsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_organization_invitation_create = organization_invitation_create;

    let uri_str = format!("{}/api/organizations/{organization_id}/invitations/", configuration.base_path, organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_invitation_create);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationInvitationCreate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationInvitationCreate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsInvitationsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an organization invitation.  The response is a 204 No Content if successful.  **On the command line:**  ```bash blind organizations invitations destroy --organization-id \"<organization-id>\" --id \"<invitation-id>\" ```
pub async fn organizations_invitations_destroy(configuration: &configuration::Configuration, id: &str, organization_id: &str) -> Result<(), Error<OrganizationsInvitationsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;

    let uri_str = format!("{}/api/organizations/{organization_id}/invitations/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsInvitationsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return a list of all organization invitations, including those which have already been accepted.  The response is a list of invitation objects.  **On the command line:**  ```bash blind organizations invitations list --organization-id \"<organization-id>\" ```
pub async fn organizations_invitations_list(configuration: &configuration::Configuration, organization_id: &str, limit: Option<i32>, offset: Option<i32>) -> Result<Vec<models::OrganizationInvitation>, Error<OrganizationsInvitationsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/api/organizations/{organization_id}/invitations/", configuration.base_path, organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OrganizationInvitation&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OrganizationInvitation&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsInvitationsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update one or more fields of an organization invitation. This does not replace the entire invitation, it only updates the fields provided in the request.  The response is the updated invitation object.  **On the command line:**  ```bash blind organizations invitations partial-update --organization-id \"<organization-id>\" --id \"<invitation-id>\" --data organization-invitation-update.json ```
pub async fn organizations_invitations_partial_update(configuration: &configuration::Configuration, id: &str, organization_id: &str, patched_organization_invitation: Option<models::PatchedOrganizationInvitation>) -> Result<models::OrganizationInvitation, Error<OrganizationsInvitationsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;
    let p_patched_organization_invitation = patched_organization_invitation;

    let uri_str = format!("{}/api/organizations/{organization_id}/invitations/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_organization_invitation);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationInvitation`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationInvitation`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsInvitationsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a single organization invitation by its ID.  The response is the invitation object.  **On the command line:**  ```bash blind organizations invitations retrieve --organization-id \"<organization-id>\" --id \"<invitation-id>\" ```
pub async fn organizations_invitations_retrieve(configuration: &configuration::Configuration, id: &str, organization_id: &str) -> Result<models::OrganizationInvitation, Error<OrganizationsInvitationsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;

    let uri_str = format!("{}/api/organizations/{organization_id}/invitations/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationInvitation`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationInvitation`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsInvitationsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an organization invitation.  The response is the updated invitation object.  **On the command line:**  ```bash blind organizations invitations update --organization-id \"<organization-id>\" --id \"<invitation-id>\" --data organization-invitation.json ```
pub async fn organizations_invitations_update(configuration: &configuration::Configuration, id: &str, organization_id: &str, organization_invitation: models::OrganizationInvitation) -> Result<models::OrganizationInvitation, Error<OrganizationsInvitationsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;
    let p_organization_invitation = organization_invitation;

    let uri_str = format!("{}/api/organizations/{organization_id}/invitations/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_invitation);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationInvitation`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationInvitation`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsInvitationsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query for a list of all organizations that the currently authenticated user has access to.  The response will be a list of organization objects.  **On the command line:**  ```bash blind organizations list ```
pub async fn organizations_list(configuration: &configuration::Configuration, created: Option<String>, id: Option<&str>, is_active: Option<bool>, limit: Option<i32>, modified: Option<String>, name: Option<&str>, offset: Option<i32>, slug: Option<&str>, users: Option<Vec<String>>) -> Result<Vec<models::Organization>, Error<OrganizationsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_created = created;
    let p_id = id;
    let p_is_active = is_active;
    let p_limit = limit;
    let p_modified = modified;
    let p_name = name;
    let p_offset = offset;
    let p_slug = slug;
    let p_users = users;

    let uri_str = format!("{}/api/organizations/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_created {
        req_builder = req_builder.query(&[("created", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_active {
        req_builder = req_builder.query(&[("is_active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified {
        req_builder = req_builder.query(&[("modified", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_users {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("users".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("users", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Organization&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Organization&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a single owner of an organization by its ID.  The response will be the user object of the owner.  **On the command line:**  ```bash blind organizations owner --id \"<organization-id>\" ```
pub async fn organizations_owner(configuration: &configuration::Configuration, id: &str) -> Result<models::Organization, Error<OrganizationsOwnerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/api/organizations/{id}/owner/", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Organization`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Organization`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOwnerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update one or more fields of an organization. This does not replace the entire organization, it only updates the fields provided in the request.  The response will be the updated organization object.  **On the command line:**  ```bash blind organizations partial-update --id \"<organization-id>\" --data organization-update.json ```
pub async fn organizations_partial_update(configuration: &configuration::Configuration, id: &str, patched_organization_update: Option<models::PatchedOrganizationUpdate>) -> Result<models::OrganizationUpdate, Error<OrganizationsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_patched_organization_update = patched_organization_update;

    let uri_str = format!("{}/api/organizations/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_organization_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUpdate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUpdate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a single organization by its ID.  The response will be the organization object.  **On the command line:**  ```bash blind organizations retrieve --id \"<organization-id>\" ```
pub async fn organizations_retrieve(configuration: &configuration::Configuration, id: &str) -> Result<models::Organization, Error<OrganizationsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/api/organizations/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Organization`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Organization`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a member to a team if you have permissions to manage that team.
pub async fn organizations_teams_add_member(configuration: &configuration::Configuration, id: &str, organization_id: &str, organizations_teams_add_member_request: Option<models::OrganizationsTeamsAddMemberRequest>) -> Result<serde_json::Value, Error<OrganizationsTeamsAddMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;
    let p_organizations_teams_add_member_request = organizations_teams_add_member_request;

    let uri_str = format!("{}/api/organizations/{organization_id}/teams/{id}/add_member/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organizations_teams_add_member_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsTeamsAddMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new Team object.
pub async fn organizations_teams_create(configuration: &configuration::Configuration, organization_id: &str, team: models::Team) -> Result<models::Team, Error<OrganizationsTeamsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_team = team;

    let uri_str = format!("{}/api/organizations/{organization_id}/teams/", configuration.base_path, organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_team);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Team`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Team`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsTeamsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a Team object by its ID.
pub async fn organizations_teams_destroy(configuration: &configuration::Configuration, id: &str, organization_id: &str) -> Result<(), Error<OrganizationsTeamsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;

    let uri_str = format!("{}/api/organizations/{organization_id}/teams/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsTeamsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all Team objects that you have access to.
pub async fn organizations_teams_list(configuration: &configuration::Configuration, organization_id: &str, dataset: Option<&str>, dataset_slug: Option<&str>, id: Option<&str>, limit: Option<i32>, members: Option<Vec<String>>, name: Option<&str>, offset: Option<i32>, organization: Option<&str>, schema: Option<&str>, schema_slug: Option<&str>, slug: Option<&str>) -> Result<Vec<models::Team>, Error<OrganizationsTeamsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_dataset = dataset;
    let p_dataset_slug = dataset_slug;
    let p_id = id;
    let p_limit = limit;
    let p_members = members;
    let p_name = name;
    let p_offset = offset;
    let p_organization = organization;
    let p_schema = schema;
    let p_schema_slug = schema_slug;
    let p_slug = slug;

    let uri_str = format!("{}/api/organizations/{organization_id}/teams/", configuration.base_path, organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_dataset {
        req_builder = req_builder.query(&[("dataset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dataset_slug {
        req_builder = req_builder.query(&[("dataset_slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_members {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("members".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("members", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_organization {
        req_builder = req_builder.query(&[("organization", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_schema {
        req_builder = req_builder.query(&[("schema", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_schema_slug {
        req_builder = req_builder.query(&[("schema_slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Team&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Team&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsTeamsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Partially update a Team object by its ID. This only replaces the specified fields.
pub async fn organizations_teams_partial_update(configuration: &configuration::Configuration, id: &str, organization_id: &str, patched_team: Option<models::PatchedTeam>) -> Result<models::Team, Error<OrganizationsTeamsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;
    let p_patched_team = patched_team;

    let uri_str = format!("{}/api/organizations/{organization_id}/teams/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_team);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Team`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Team`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsTeamsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a member from a team if you have permissions to manage that team.
pub async fn organizations_teams_remove_member(configuration: &configuration::Configuration, id: &str, organization_id: &str, organizations_teams_add_member_request: Option<models::OrganizationsTeamsAddMemberRequest>) -> Result<serde_json::Value, Error<OrganizationsTeamsRemoveMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;
    let p_organizations_teams_add_member_request = organizations_teams_add_member_request;

    let uri_str = format!("{}/api/organizations/{organization_id}/teams/{id}/remove_member/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organizations_teams_add_member_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsTeamsRemoveMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a single Team object by its ID.
pub async fn organizations_teams_retrieve(configuration: &configuration::Configuration, id: &str, organization_id: &str) -> Result<models::Team, Error<OrganizationsTeamsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;

    let uri_str = format!("{}/api/organizations/{organization_id}/teams/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Team`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Team`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsTeamsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a Team object by its ID. This completely replaces the object.
pub async fn organizations_teams_update(configuration: &configuration::Configuration, id: &str, organization_id: &str, team: models::Team) -> Result<models::Team, Error<OrganizationsTeamsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;
    let p_team = team;

    let uri_str = format!("{}/api/organizations/{organization_id}/teams/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_team);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Team`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Team`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsTeamsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Replace an organization with the data provided in the request.  The response will be the updated organization object.  **On the command line:**  ```bash blind organizations update --id \"<organization-id>\" --data organization.json ```
pub async fn organizations_update(configuration: &configuration::Configuration, id: &str, organization_update: models::OrganizationUpdate) -> Result<models::OrganizationUpdate, Error<OrganizationsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_update = organization_update;

    let uri_str = format!("{}/api/organizations/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUpdate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUpdate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a new user to an organization.  The response is the newly added user object.  **On the command line:**  ```bash blind organizations users create --organization-id \"<organization-id>\" --data organization-user.json ```
pub async fn organizations_users_create(configuration: &configuration::Configuration, organization_id: &str, organization_user_create: models::OrganizationUserCreate) -> Result<models::OrganizationUserCreate, Error<OrganizationsUsersCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_organization_user_create = organization_user_create;

    let uri_str = format!("{}/api/organizations/{organization_id}/users/", configuration.base_path, organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_create);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserCreate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserCreate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsUsersCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a user from an organization.  The response is a 204 No Content if successful.  **On the command line:**  ```bash blind organizations users destroy --organization-id \"<organization-id>\" --id \"<user-id>\" ```
pub async fn organizations_users_destroy(configuration: &configuration::Configuration, id: &str, organization_id: &str) -> Result<(), Error<OrganizationsUsersDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;

    let uri_str = format!("{}/api/organizations/{organization_id}/users/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsUsersDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return a list of all users of an organization.  The response is a list of user objects belonging to the organization.  **On the command line:**  ```bash blind organizations users list --organization-id \"<organization-id>\" ```
pub async fn organizations_users_list(configuration: &configuration::Configuration, organization_id: &str, created: Option<String>, has_identity: Option<bool>, id: Option<&str>, is_admin: Option<bool>, limit: Option<i32>, modified: Option<String>, offset: Option<i32>, organization: Option<&str>, user: Option<&str>) -> Result<Vec<models::OrganizationUser>, Error<OrganizationsUsersListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_created = created;
    let p_has_identity = has_identity;
    let p_id = id;
    let p_is_admin = is_admin;
    let p_limit = limit;
    let p_modified = modified;
    let p_offset = offset;
    let p_organization = organization;
    let p_user = user;

    let uri_str = format!("{}/api/organizations/{organization_id}/users/", configuration.base_path, organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_created {
        req_builder = req_builder.query(&[("created", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_has_identity {
        req_builder = req_builder.query(&[("has_identity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_admin {
        req_builder = req_builder.query(&[("is_admin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified {
        req_builder = req_builder.query(&[("modified", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_organization {
        req_builder = req_builder.query(&[("organization", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_user {
        req_builder = req_builder.query(&[("user", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OrganizationUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OrganizationUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsUsersListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update one or more fields of a user of an organization. This does not replace the entire user, it only updates the fields provided in the request.  The response is the updated user object.  **On the command line:**  ```bash blind organizations users partial-update --organization-id \"<organization-id>\" --id \"<user-id>\" --data organization-user-update.json ```
pub async fn organizations_users_partial_update(configuration: &configuration::Configuration, id: &str, organization_id: &str, patched_organization_user_update: Option<models::PatchedOrganizationUserUpdate>) -> Result<models::OrganizationUserUpdate, Error<OrganizationsUsersPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;
    let p_patched_organization_user_update = patched_organization_user_update;

    let uri_str = format!("{}/api/organizations/{organization_id}/users/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_organization_user_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserUpdate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserUpdate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsUsersPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a single user of an organization by their ID.  The response is the user object.  **On the command line:**  ```bash blind organizations users retrieve --organization-id \"<organization-id>\" --id \"<user-id>\" ```
pub async fn organizations_users_retrieve(configuration: &configuration::Configuration, id: &str, organization_id: &str) -> Result<models::OrganizationUser, Error<OrganizationsUsersRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;

    let uri_str = format!("{}/api/organizations/{organization_id}/users/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUser`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUser`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsUsersRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Replace a user of an organization with the data provided in the request.  The response is the updated user object.  **On the command line:**  ```bash blind organizations users update --organization-id \"<organization-id>\" --id \"<user-id>\" --data organization-user.json ```
pub async fn organizations_users_update(configuration: &configuration::Configuration, id: &str, organization_id: &str, organization_user_update: Option<models::OrganizationUserUpdate>) -> Result<models::OrganizationUserUpdate, Error<OrganizationsUsersUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_id = organization_id;
    let p_organization_user_update = organization_user_update;

    let uri_str = format!("{}/api/organizations/{organization_id}/users/{id}/", configuration.base_path, id=crate::apis::urlencode(p_id), organization_id=crate::apis::urlencode(p_organization_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserUpdate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserUpdate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsUsersUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

