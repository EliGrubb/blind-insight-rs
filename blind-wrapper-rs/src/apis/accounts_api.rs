/*
 * Blind Insight REST API
 *
 * End-to-end encrypted datastore
 *
 * The version of the OpenAPI document: 10.6.2
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest::{self, cookie};
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};
use reqwest::cookie::Jar;
use std::sync::Arc;


/// struct for typed errors of method [`accounts_change_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsChangePasswordError {
    Status400(models::PasswordChangedError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_login`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsLoginError {
    Status400(models::LoginSuccessfulError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_logout`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsLogoutError {
    Status400(models::LogoutSuccessfulError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_profile_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsProfileCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_profile_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsProfilePartialUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_profile_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsProfileRetrieveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_profile_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsProfileUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_register`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsRegisterError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_register_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsRegisterEmailError {
    Status400(models::RegisteredEmailError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_reset_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsResetPasswordError {
    Status400(models::PasswordResetError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_send_reset_password_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsSendResetPasswordLinkError {
    Status400(models::ResetPasswordLinkSentError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_verify_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsVerifyEmailError {
    Status400(models::VerifiedEmailError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_verify_registration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsVerifyRegistrationError {
    Status400(models::AccountVerifiedError),
    UnknownValue(serde_json::Value),
}


/// Change the password of the currently authenticated user. The `old_password` field must match the currently set password. The `password` and `password_confirm` fields must match.  The response will be a detail message indicating if the password change was successful.  **On the command line:**  ```bash blind accounts change-password --data password-change.json ```
pub async fn accounts_change_password(configuration: &configuration::Configuration, change_password: models::ChangePassword) -> Result<models::PasswordChanged, Error<AccountsChangePasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_change_password = change_password;

    let uri_str = format!("{}/api/accounts/change-password/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_change_password);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/json");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PasswordChanged`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PasswordChanged`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsChangePasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Log in a user using their email and password. On success, returns a JSON web token which should be included in the `Authorization` header for all subsequent API requests in client implementations.  The response will be a detail message indicating if the login was successful.  **On the command line:**  ```bash blind accounts login --data login.json ```
pub async fn accounts_login(configuration: &configuration::Configuration, default_login: models::DefaultLogin) -> Result<models::LoginSuccessful, Error<AccountsLoginError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_default_login = default_login;

    let uri_str = format!("{}/api/accounts/login/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_default_login);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginSuccessful`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginSuccessful`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsLoginError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Log out the currently authenticated user. This simply invalidates the JSON web token used.  This is separate from the porcelain `blind logout` command which removes stored credentials on the local machine.  The response will be a detail message indicating if the logout was successful.  **On the command line:**  ```bash blind accounts logout ```
pub async fn accounts_logout(configuration: &configuration::Configuration, logout: Option<models::Logout>) -> Result<models::LogoutSuccessful, Error<AccountsLogoutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_logout = logout;

    let uri_str = format!("{}/api/accounts/logout/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_logout);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LogoutSuccessful`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LogoutSuccessful`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsLogoutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a profile for the currently authenticated user. This is useful if you don't have a profile yet, or if you want to edit an existing profile.  The response will be the newly created profile object.  **On the command line:**  ```bash blind accounts profile create --data profile.json ```
pub async fn accounts_profile_create(configuration: &configuration::Configuration, default_user_profile: Option<models::DefaultUserProfile>) -> Result<models::DefaultUserProfile, Error<AccountsProfileCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_default_user_profile = default_user_profile;

    let uri_str = format!("{}/api/accounts/profile/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_default_user_profile);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DefaultUserProfile`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DefaultUserProfile`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsProfileCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update one or more fields of the currently authenticated user's profile. This does not replace the entire profile, it only updates the fields provided in the request.  The response will be the updated profile object.  **On the command line:**  ```bash blind accounts profile partial-update --data profile-update.json ```
pub async fn accounts_profile_partial_update(configuration: &configuration::Configuration, patched_default_user_profile: Option<models::PatchedDefaultUserProfile>) -> Result<models::DefaultUserProfile, Error<AccountsProfilePartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_patched_default_user_profile = patched_default_user_profile;

    let uri_str = format!("{}/api/accounts/profile/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_default_user_profile);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DefaultUserProfile`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DefaultUserProfile`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsProfilePartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the profile of the currently authenticated user.  The response will be the profile object.  **On the command line:**  ```bash blind accounts profile retrieve ```
pub async fn accounts_profile_retrieve(configuration: &configuration::Configuration, ) -> Result<models::DefaultUserProfile, Error<AccountsProfileRetrieveError>> {

    let uri_str = format!("{}/api/accounts/profile/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DefaultUserProfile`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DefaultUserProfile`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsProfileRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Replace the currently authenticated user's profile with the data provided in the request. Fields not specified in the request will be dropped.  The response will be the updated profile object.  **On the command line:**  ```bash blind accounts profile update --data profile.json ```
pub async fn accounts_profile_update(configuration: &configuration::Configuration, default_user_profile: Option<models::DefaultUserProfile>) -> Result<models::DefaultUserProfile, Error<AccountsProfileUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_default_user_profile = default_user_profile;

    let uri_str = format!("{}/api/accounts/profile/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_default_user_profile);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DefaultUserProfile`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DefaultUserProfile`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsProfileUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint registers a new user. The user will receive an email with a link to activate their account.  This will also create a new Organization for the user. The user will be the owner of the organization.  See the [user registration](https://docs.blindinsight.io/) documentation for more information.  The response will be the newly created user object.  **On the command line:**  You can supply record data on standard input with the `--data -` or write it to a file and give the `--data <filename>` flag.  ```bash blind accounts register --data '{   \"email\": \"demo@example.com\",   \"first_name\": \"Demo\",   \"last_name\": \"User\",   \"organization_name\": \"Demo\",   \"password\": \"pass1234\",   \"password_confirm\": \"pass1234\" }' ```
pub async fn accounts_register(configuration: &configuration::Configuration, organization_register_user: models::OrganizationRegisterUser) -> Result<models::OrganizationUserProfile, Error<AccountsRegisterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_register_user = organization_register_user;

    let uri_str = format!("{}/api/accounts/register/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_register_user);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserProfile`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserProfile`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsRegisterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Register a new email address for the currently authenticated user. This is useful if the user wants to change email addresses associated with their account.  The new email must be verified before it is associated with the account.  The response will be a detail message indicating if the email was registered.  **On the command line:**  ```bash blind accounts register-email --data '{\"email\": \"demo-example@example.com\"}' ```
pub async fn accounts_register_email(configuration: &configuration::Configuration, default_register_email: models::DefaultRegisterEmail) -> Result<models::RegisteredEmail, Error<AccountsRegisterEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_default_register_email = default_register_email;

    let uri_str = format!("{}/api/accounts/register-email/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_default_register_email);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RegisteredEmail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RegisteredEmail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsRegisterEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reset the password of the given user using the provided signature and timestamp.  This endpoint is generally only used by an administrator to reset a user's password.  The response will be a detail message indicating if the password reset was successful.  **On the command line:**  ```bash blind accounts reset-password --data reset-password.json ```
pub async fn accounts_reset_password(configuration: &configuration::Configuration, reset_password: models::ResetPassword) -> Result<models::PasswordReset, Error<AccountsResetPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_reset_password = reset_password;

    let uri_str = format!("{}/api/accounts/reset-password/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_reset_password);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PasswordReset`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PasswordReset`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsResetPasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a password reset link email to the user with the given email address. This endpoint does not require the user to have activated their account yet.  The response will be a detail message indicating if the reset link was sent.  **On the command line:**  ```bash blind accounts send-reset-password-link --data '{\"email\": \"demo@example.com\"}' ```
pub async fn accounts_send_reset_password_link(configuration: &configuration::Configuration, default_send_reset_password_link: models::DefaultSendResetPasswordLink) -> Result<models::ResetPasswordLinkSent, Error<AccountsSendResetPasswordLinkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_default_send_reset_password_link = default_send_reset_password_link;

    let uri_str = format!("{}/api/accounts/send-reset-password-link/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_default_send_reset_password_link);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResetPasswordLinkSent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResetPasswordLinkSent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsSendResetPasswordLinkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Verify the authenticated user's email address. This is useful if you want to automate onboarding of users within your organization.  The response will be a detail message indicating if the verification was successful.  **On the command line:**  ```bash blind accounts verify-email --data verification.json ```
pub async fn accounts_verify_email(configuration: &configuration::Configuration, verify_email: models::VerifyEmail) -> Result<models::VerifiedEmail, Error<AccountsVerifyEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_verify_email = verify_email;

    let uri_str = format!("{}/api/accounts/verify-email/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_verify_email);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifiedEmail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifiedEmail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsVerifyEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint verifies a new user with their user ID, a timestamp, and a signature. These values must come from the received verification email.  The response will be a detail message indicating if the verification was successful.  **On the command line:**  ```bash blind accounts verify-registration --data registration.json ```
pub async fn accounts_verify_registration(configuration: &configuration::Configuration, verify_registration: models::VerifyRegistration) -> Result<models::AccountVerified, Error<AccountsVerifyRegistrationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_verify_registration = verify_registration;

    let uri_str = format!("{}/api/accounts/verify-registration/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_verify_registration);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountVerified`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountVerified`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsVerifyRegistrationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

